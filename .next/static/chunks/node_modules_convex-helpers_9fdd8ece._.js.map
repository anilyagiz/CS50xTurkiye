{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/github/nakafa.com-main/node_modules/convex-helpers/index.js"],"sourcesContent":["/**\n * asyncMap returns the results of applying an async function over an list.\n *\n * The list can even be a promise, or an iterable like a Set.\n * @param list - Iterable object of items, e.g. an Array, Set, Object.keys\n * @param asyncTransform\n * @returns\n */\nexport async function asyncMap(list, asyncTransform) {\n    const promises = [];\n    let index = 0;\n    list = await list;\n    for (const item of list) {\n        promises.push(asyncTransform(item, index));\n        index += 1;\n    }\n    return Promise.all(promises);\n}\n/**\n * Filters out null elements from an array.\n * @param list List of elements that might be null.\n * @returns List of elements with nulls removed.\n */\nexport function pruneNull(list) {\n    return list.filter((i) => i !== null);\n}\nexport class NullDocumentError extends Error {\n}\n/**\n * Throws if there is a null element in the array.\n * @param list List of elements that might have a null element.\n * @returns Same list of elements with a refined type.\n */\nexport function nullThrows(doc, message) {\n    if (doc === null) {\n        throw new NullDocumentError(message ?? \"Unexpected null document.\");\n    }\n    return doc;\n}\n/**\n * pick helps you pick keys from an object more concisely.\n *\n * e.g. `pick({a: v.string(), b: v.number()}, [\"a\"])` is equivalent to\n * `{a: v.string()}`\n * The alternative could be something like:\n * ```js\n * const obj = { a: v.string(), b: v.number() };\n * // pick does the following\n * const { a } = obj;\n * const onlyA = { a };\n * ```\n *\n * @param obj The object to pick from. Often like { a: v.string() }\n * @param keys The keys to pick from the object.\n * @returns A new object with only the keys you picked and their values.\n */\nexport function pick(obj, keys) {\n    return Object.fromEntries(Object.entries(obj).filter(([k]) => keys.includes(k)));\n}\n/**\n * omit helps you omit keys from an object more concisely.\n *\n * e.g. `omit({a: v.string(), b: v.number()}, [\"a\"])` is equivalent to\n * `{b: v.number()}`\n *\n * The alternative could be something like:\n * ```js\n * const obj = { a: v.string(), b: v.number() };\n * // omit does the following\n * const { a, ...rest } = obj;\n * const withoutA = rest;\n * ```\n *\n * @param obj The object to return a copy of without the specified keys.\n * @param keys The keys to omit from the object.\n * @returns A new object with the keys you omitted removed.\n */\nexport function omit(obj, keys) {\n    return Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k)));\n}\n/**\n * Removes the _id and _creationTime fields from an object.\n * This enables easily cloning a Convex document like:\n * ```ts\n * const doc = await db.get(id);\n * const clone = withoutSystemFields(doc);\n * await db.insert(table, clone);\n * ```\n * @param obj The object to remove the _id and _creationTime fields from.\n * @returns A new object with the _id and _creationTime fields removed.\n */\nexport function withoutSystemFields(obj) {\n    return omit(obj, [\"_id\", \"_creationTime\"]);\n}\n// Type utils:\nconst _error = Symbol();\n/**\n * A utility to validate truthiness at runtime, providing a type guard\n *\n * @example\n * ```ts\n * const x: string | null = getValue();\n * assert(x);\n * // x is now of type string\n * ```\n * @param arg A value to assert the truthiness of.\n * @param message An optional message to throw if the value is not truthy.\n */\nexport function assert(value, message) {\n    if (!value) {\n        throw new Error(message);\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;;;;;;;;;;;;;AACM,eAAe,SAAS,IAAI,EAAE,cAAc;IAC/C,MAAM,WAAW,EAAE;IACnB,IAAI,QAAQ;IACZ,OAAO,MAAM;IACb,KAAK,MAAM,QAAQ,KAAM;QACrB,SAAS,IAAI,CAAC,eAAe,MAAM;QACnC,SAAS;IACb;IACA,OAAO,QAAQ,GAAG,CAAC;AACvB;AAMO,SAAS,UAAU,IAAI;IAC1B,OAAO,KAAK,MAAM,CAAC,CAAC,IAAM,MAAM;AACpC;AACO,MAAM,0BAA0B;AACvC;AAMO,SAAS,WAAW,GAAG,EAAE,OAAO;IACnC,IAAI,QAAQ,MAAM;QACd,MAAM,IAAI,kBAAkB,oBAAA,qBAAA,UAAW;IAC3C;IACA,OAAO;AACX;AAkBO,SAAS,KAAK,GAAG,EAAE,IAAI;IAC1B,OAAO,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,KAAK,MAAM,CAAC;YAAC,CAAC,EAAE;eAAK,KAAK,QAAQ,CAAC;;AAChF;AAmBO,SAAS,KAAK,GAAG,EAAE,IAAI;IAC1B,OAAO,OAAO,WAAW,CAAC,OAAO,OAAO,CAAC,KAAK,MAAM,CAAC;YAAC,CAAC,EAAE;eAAK,CAAC,KAAK,QAAQ,CAAC;;AACjF;AAYO,SAAS,oBAAoB,GAAG;IACnC,OAAO,KAAK,KAAK;QAAC;QAAO;KAAgB;AAC7C;AACA,cAAc;AACd,MAAM,SAAS;AAaR,SAAS,OAAO,KAAK,EAAE,OAAO;IACjC,IAAI,CAAC,OAAO;QACR,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 79, "column": 0}, "map": {"version":3,"sources":["file:///D:/github/nakafa.com-main/node_modules/convex-helpers/validators.js"],"sourcesContent":["import { asObjectValidator, v } from \"convex/values\";\nimport { assert } from \"./index.js\";\n/**\n * Helper for defining a union of literals more concisely.\n *\n * e.g. `literals(\"a\", 1, false)` is equivalent to\n * `v.union(v.literal(\"a\"), v.literal(1), v.literal(false))`\n * To use with an array:\n * ```ts\n * const myLiterals = [\"a\", 1, false] as const;\n * const literalValidator = literals(...myLiterals)\n * ```\n * A similar result can be achieved with `v.union(...myLiterals.map(v.literal))`\n * however the type of each union member will be the union of literal types,\n * rather than each member being a specific literal type.\n *\n * @param args Values you want to use in a union of literals.\n * @returns A validator for the union of the literals.\n */\nexport const literals = (...args) => {\n    return v.union(...args.map(v.literal));\n};\n/**\n * nullable define a validator that can be the value or null more consisely.\n *\n * @param x The validator to make nullable. As in, it can be the value or null.\n * @returns A new validator that can be the value or null.\n */\nexport const nullable = (x) => v.union(v.null(), x);\nexport function partial(fieldsOrObjOrUnion) {\n    if (fieldsOrObjOrUnion.isConvexValidator) {\n        if (fieldsOrObjOrUnion.kind === \"object\") {\n            return partialVObject(fieldsOrObjOrUnion);\n        }\n        if (fieldsOrObjOrUnion.kind === \"union\") {\n            return partialUnion(fieldsOrObjOrUnion);\n        }\n        throw new Error(\"partial only works with union or object Validators, or a Record<string, Validator> currently\");\n    }\n    return partialFields(fieldsOrObjOrUnion);\n}\n/**\n * partialFields helps you define an object of optional validators more concisely.\n *\n * e.g. `partialFields({a: v.string(), b: v.number()})` is equivalent to\n * `{a: v.optional(v.string()), b: v.optional(v.number())}`\n *\n * @param obj The object of validators to make optional. e.g. {a: v.string()}\n * @returns A new object of validators that can be the value or undefined.\n */\nfunction partialFields(obj) {\n    return Object.fromEntries(Object.entries(obj).map(([k, vv]) => [\n        k,\n        vv.isOptional === \"optional\" ? vv : v.optional(vv),\n    ]));\n}\n/**\n * partialObject helps you define an object of optional validators more concisely.\n *\n * e.g. `partialObject({a: v.string(), b: v.number()})` is equivalent to\n * `{a: v.optional(v.string()), b: v.optional(v.number())}`\n *\n * @param obj The object of validators to make optional. e.g. {a: v.string()}\n * @returns A new object of validators that can be the value or undefined.\n */\nfunction partialVObject(obj) {\n    const o = v.object(partialFields(obj.fields));\n    if (obj.isOptional === \"optional\") {\n        return v.optional(o);\n    }\n    return o;\n}\nfunction partialUnion(union) {\n    const u = v.union(...union.members.map((m) => {\n        assert(m.isOptional === \"required\", \"Union members cannot be optional\");\n        if (m.kind === \"object\") {\n            return partialVObject(m);\n        }\n        if (m.kind === \"union\") {\n            return partialUnion(m);\n        }\n        throw new Error(`Invalid union member type: ${m.kind}`);\n    }));\n    if (union.isOptional === \"optional\") {\n        return v.optional(u);\n    }\n    return u;\n}\n// Shorthand for defining validators that look like types.\n/** @deprecated Use `v.string()` instead. Any string value. */\nexport const string = v.string();\n/** @deprecated Use `v.float64()` instead. JavaScript number, represented as a float64 in the database. */\nexport const number = v.float64();\n/** @deprecated Use `v.float64()` instead. JavaScript number, represented as a float64 in the database. */\nexport const float64 = v.float64();\n/** @deprecated Use `v.boolean()` instead. boolean value. For typing it only as true, use `l(true)` */\nexport const boolean = v.boolean();\n/** @deprecated Use `v.int64()` instead. bigint, though stored as an int64 in the database. */\nexport const biging = v.int64();\n/** @deprecated Use `v.int64()` instead. bigint, though stored as an int64 in the database. */\nexport const int64 = v.int64();\n/** @deprecated Use `v.any()` instead. Any Convex value */\nexport const any = v.any();\n/** @deprecated Use `v.null()` instead. Null value. Underscore is so it doesn't shadow the null builtin */\nexport const null_ = v.null();\n/** @deprecated Use `v.*()` instead. */\nexport const { id, object, array, bytes, literal, optional, union } = v;\n/** @deprecated Use `v.bytes()` instead. ArrayBuffer validator. */\nexport const arrayBuffer = v.bytes();\n/**\n * Utility to get the validators for fields associated with a table.\n * e.g. for systemFields(\"users\") it would return:\n * { _id: v.id(\"users\"), _creationTime: v.number() }\n *\n * @param tableName The table name in the schema.\n * @returns Validators for the system fields: _id and _creationTime\n */\nexport const systemFields = (tableName) => ({\n    _id: v.id(tableName),\n    _creationTime: v.number(),\n});\n/**\n * Utility to add system fields to an object with fields mapping to validators.\n * e.g. withSystemFields(\"users\", { name: v.string() }) would return:\n * { name: v.string(), _id: v.id(\"users\"), _creationTime: v.number() }\n *\n * @param tableName Table name in the schema.\n * @param fields The fields of the table mapped to their validators.\n * @returns The fields plus system fields _id and _creationTime.\n */\nexport const withSystemFields = (tableName, fields) => {\n    const system = systemFields(tableName);\n    return {\n        ...fields,\n        ...system,\n    };\n};\nexport function addFieldsToValidator(validatorOrFields, fields) {\n    const validator = asObjectValidator(validatorOrFields);\n    if (Object.keys(fields).length === 0) {\n        return validator;\n    }\n    switch (validator.kind) {\n        case \"object\":\n            return v.object(intersectValidators(validator.fields, fields));\n        case \"union\":\n            return v.union(...validator.members.map((m) => addFieldsToValidator(m, fields)));\n        default:\n            throw new Error(\"Cannot add arguments to a validator that is not an object or union.\");\n    }\n}\nfunction intersectValidators(fields, fields2) {\n    const specificFields = { ...fields };\n    for (const [k, v] of Object.entries(fields2)) {\n        const existing = specificFields[k];\n        if (existing) {\n            if (existing.kind !== v.kind) {\n                // TODO: handle unions & literals & other sub-types (incl. optionals)\n                throw new Error(`Cannot intersect validators with different kinds: ${existing.kind} and ${v.kind}`);\n            }\n            if (existing.isOptional !== v.isOptional) {\n                if (existing.isOptional === \"optional\") {\n                    // prefer the required validator\n                    specificFields[k] = v;\n                }\n            }\n        }\n        else {\n            specificFields[k] = v;\n        }\n    }\n    return specificFields;\n}\nexport const doc = (schema, tableName) => {\n    function addSystemFields(validator) {\n        if (validator.kind === \"object\") {\n            return v.object({\n                ...validator.fields,\n                ...systemFields(tableName),\n            });\n        }\n        if (validator.kind !== \"union\") {\n            throw new Error(\"Only object and union validators are supported for documents\");\n        }\n        return v.union(...validator.members.map(addSystemFields));\n    }\n    return addSystemFields(schema.tables[tableName].validator);\n};\n/**\n * Creates a validator with a type-safe `.id(table)` and a new `.doc(table)`.\n * Can be used instead of `v` for function arugments & return validators.\n * However, it cannot be used as part of defining a schema, since it would be\n * circular.\n * ```ts\n * import schema from \"./schema\";\n * export const vv = typedV(schema);\n *\n * export const myQuery = query({\n *   args: { docId: vv.id(\"mytable\") },\n *   returns: vv.doc(\"mytable\"),\n *   handler: (ctx, args) => ctx.db.get(args.docId),\n * })\n *\n * @param schema Typically from `import schema from \"./schema\"`.\n * @returns A validator like `v` with type-safe `v.id` and a new `v.doc`\n */\nexport function typedV(schema) {\n    return {\n        ...v,\n        /**\n         * Similar to v.id but is type-safe on the table name.\n         * @param tableName A table named in your schema.\n         * @returns A validator for an ID to the named table.\n         */\n        id: (tableName) => v.id(tableName),\n        /**\n         * Generates a validator for a document, including system fields.\n         * To be used in validators when passing a full document in or out of a\n         * function.\n         * @param tableName A table named in your schema.\n         * @returns A validator that matches the schema validator, adding _id and\n         * _creationTime. If the validator was a union, it will update all documents\n         * recursively, but will currently lose the VUnion-specific type.\n         */\n        doc: (tableName) => doc(schema, tableName),\n    };\n}\n/**\n * A string validator that is a branded string type.\n *\n * Read more at https://stack.convex.dev/using-branded-types-in-validators\n *\n * @param _brand - A unique string literal to brand the string with\n */\nexport const brandedString = (_brand) => v.string();\n/** Mark fields as deprecated with this permissive validator typed as null */\nexport const deprecated = v.optional(v.any());\n/** A maximally permissive validator that type checks as a given validator.\n *\n * If you want to have types that match some validator but you have invalid data\n * and you want to temporarily not validate schema for this field,\n * you can use this function to cast the permissive validator.\n *\n * Example in a schema:\n * ```ts\n * export default defineSchema({\n *   myTable: defineTable({\n *    myString: pretend(v.array(v.string())),\n *   }),\n * });\n * //...in some mutation\n * ctx.db.insert(\"myTable\", { myString: 123 as any }); // no runtime error\n * ```\n * Example in function argument validation:\n * ```ts\n * const myQuery = defineQuery({\n *   args: { myNumber: pretend(v.number()) },\n *   handler: async (ctx, args) => {\n *     // args.myNumber is typed as number, but it's not validated.\n *     const num = typeof args.myNumber === \"number\" ?\n *       args.myNumber : Number(args.myNumber);\n *   },\n * });\n */\nexport const pretend = (_typeToImmitate) => v.optional(v.any());\n/** A validator that validates as optional but type checks as required.\n *\n * If you want to assume a field is set for type checking, but your data may not\n * actually have it set for all documents (e.g. when adding a new field),\n * you can use this function to allow the field to be unset at runtime.\n * This is unsafe, but can be convenient in these situations:\n *\n * 1. You are developing locally and want to add a required field and write\n *   code assuming it is set. Once you push the code & schema, you can update\n *   the data to match before running your code.\n * 2. You are going to run a migration right after pushing code, and are ok with\n *   and you don't want to edit your code to handle the field being unset,\n *   your app being in an inconsistent state until the migration completes.\n *\n * This differs from {@link pretend} in that it type checks the inner validator,\n * if the value is provided.\n *\n * Example in a schema:\n * ```ts\n * export default defineSchema({\n *   myTable: defineTable({\n *    myString: pretendRequired(v.array(v.string())),\n *   }),\n * });\n * //...in some mutation\n * ctx.db.insert(\"myTable\", { myString: undefined }); // no runtime error\n * ```\n * Example in function argument validation:\n * ```ts\n * const myQuery = defineQuery({\n *   args: { myNumber: pretendRequired(v.number()) },\n *   handler: async (ctx, args) => {\n *     // args.myNumber is typed as number, but it might be undefined\n *     const num = args.myNumber || 0;\n *   },\n * });\n */\nexport const pretendRequired = (optionalType) => v.optional(optionalType);\nexport class ValidationError extends Error {\n    expected;\n    got;\n    path;\n    constructor(expected, got, path) {\n        const message = `Validator error${path ? ` for ${path}` : \"\"}: Expected \\`${expected}\\`, got \\`${got}\\``;\n        super(message);\n        this.expected = expected;\n        this.got = got;\n        this.path = path;\n        this.name = \"ValidationError\";\n    }\n}\n/**\n * Validate a value against a validator.\n *\n * WARNING: This does not validate that v.id is an ID for the given table.\n * It only validates that the ID is a string. Function `args`, `returns` and\n * schema definitions will validate that the ID is an ID for the given table.\n *\n * @param validator The validator to validate against.\n * @param value The value to validate.\n * @returns Whether the value is valid against the validator.\n */\nexport function validate(validator, value, opts) {\n    let valid = true;\n    let expected = validator.kind;\n    let got;\n    if (value === undefined) {\n        if (validator.isOptional !== \"optional\") {\n            valid = false;\n        }\n    }\n    else {\n        switch (validator.kind) {\n            case \"null\": {\n                if (value !== null) {\n                    valid = false;\n                }\n                break;\n            }\n            case \"float64\": {\n                if (typeof value !== \"number\") {\n                    expected = \"number\";\n                    valid = false;\n                }\n                break;\n            }\n            case \"int64\": {\n                if (typeof value !== \"bigint\") {\n                    expected = \"bigint\";\n                    valid = false;\n                }\n                break;\n            }\n            case \"boolean\": {\n                if (typeof value !== \"boolean\") {\n                    valid = false;\n                }\n                break;\n            }\n            case \"string\": {\n                if (typeof value !== \"string\") {\n                    valid = false;\n                }\n                break;\n            }\n            case \"bytes\": {\n                if (!(value instanceof ArrayBuffer)) {\n                    valid = false;\n                }\n                break;\n            }\n            case \"any\": {\n                break;\n            }\n            case \"literal\": {\n                if (value !== validator.value) {\n                    valid = false;\n                    expected = validator.value;\n                    if ([\"string\", \"number\", \"boolean\", \"bigint\"].includes(typeof value)) {\n                        got = `\"${value}\"`;\n                    }\n                }\n                break;\n            }\n            case \"id\": {\n                if (typeof value !== \"string\") {\n                    valid = false;\n                }\n                else if (opts?.db) {\n                    expected = `Id<${validator.tableName}>`;\n                    const id = opts.db.normalizeId(validator.tableName, value);\n                    if (!id) {\n                        valid = false;\n                    }\n                }\n                break;\n            }\n            case \"array\": {\n                if (!Array.isArray(value)) {\n                    valid = false;\n                    break;\n                }\n                for (const [index, v] of value.entries()) {\n                    const path = `${opts?._pathPrefix ?? \"\"}[${index}]`;\n                    valid = validate(validator.element, v, {\n                        ...opts,\n                        _pathPrefix: path,\n                    });\n                    if (!valid) {\n                        expected = validator.element.kind;\n                        break;\n                    }\n                }\n                break;\n            }\n            case \"object\": {\n                if (typeof value !== \"object\" || value === null) {\n                    valid = false;\n                    break;\n                }\n                const prototype = Object.getPrototypeOf(value);\n                const isSimple = prototype === null ||\n                    prototype === Object.prototype ||\n                    // Objects generated from other contexts (e.g. across Node.js `vm` modules) will not satisfy the previous\n                    // conditions but are still simple objects.\n                    prototype?.constructor?.name === \"Object\";\n                if (!isSimple) {\n                    expected =\n                        (prototype?.constructor?.name ?? typeof prototype) || \"object\";\n                    valid = false;\n                    break;\n                }\n                for (const [k, fieldValidator] of Object.entries(validator.fields)) {\n                    valid = validate(fieldValidator, value[k], {\n                        ...opts,\n                        _pathPrefix: appendPath(opts, k),\n                    });\n                    if (!valid) {\n                        break;\n                    }\n                }\n                if (!opts?.allowUnknownFields) {\n                    for (const k of Object.keys(value)) {\n                        if (validator.fields[k] === undefined) {\n                            if (opts?.throw) {\n                                throw new ValidationError(\"nothing\", typeof value[k], appendPath(opts, k));\n                            }\n                            valid = false;\n                            break;\n                        }\n                    }\n                }\n                break;\n            }\n            case \"union\": {\n                valid = false;\n                let error;\n                for (const member of validator.members) {\n                    try {\n                        if (validate(member, value, opts)) {\n                            valid = true;\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        error = e;\n                    }\n                }\n                if (!valid && error) {\n                    throw error;\n                }\n                break;\n            }\n            case \"record\": {\n                if (typeof value !== \"object\" || value === null) {\n                    valid = false;\n                    break;\n                }\n                for (const [k, fieldValue] of Object.entries(value)) {\n                    valid = validate(validator.key, k, {\n                        ...opts,\n                        _pathPrefix: appendPath(opts, k),\n                    });\n                    if (!valid) {\n                        expected = validator.key.kind;\n                        break;\n                    }\n                    valid = validate(validator.value, fieldValue, {\n                        ...opts,\n                        _pathPrefix: appendPath(opts, k),\n                    });\n                    if (!valid) {\n                        expected = validator.value.kind;\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    if (!valid && opts?.throw) {\n        throw new ValidationError(expected, got ?? (value === null ? \"null\" : typeof value), opts?._pathPrefix);\n    }\n    return valid;\n}\n/**\n * Parse a value, using a Convex validator. This differs from `validate` in that\n * it strips unknown fields instead of throwing an error on them.\n *\n * @param validator - The Convex validator to parse the value against.\n * @param value - The value to parse.\n * @returns The parsed value, without fields not specified in the validator.\n */\nexport function parse(validator, value) {\n    validate(validator, value, { allowUnknownFields: true, throw: true });\n    return stripUnknownFields(validator, value);\n}\nfunction stripUnknownFields(validator, value) {\n    if (validator.isOptional === \"optional\" && value === undefined) {\n        return value;\n    }\n    assert(value !== undefined);\n    switch (validator.kind) {\n        case \"object\": {\n            const result = {};\n            for (const [k, v] of Object.entries(value)) {\n                if (validator.fields[k] !== undefined && v !== undefined) {\n                    result[k] = stripUnknownFields(validator.fields[k], v);\n                }\n            }\n            return result;\n        }\n        case \"record\": {\n            const result = {};\n            for (const [k, v] of Object.entries(value)) {\n                result[k] = stripUnknownFields(validator.value, v);\n            }\n            return result;\n        }\n        case \"array\": {\n            return value.map((e) => stripUnknownFields(validator.element, e));\n        }\n        case \"union\": {\n            // First try a strict match\n            for (const member of validator.members) {\n                if (validate(member, value, { allowUnknownFields: false })) {\n                    return stripUnknownFields(member, value);\n                }\n            }\n            // Then try a permissive match\n            for (const member of validator.members) {\n                if (validate(member, value, { allowUnknownFields: true })) {\n                    return stripUnknownFields(member, value);\n                }\n            }\n            throw new Error(\"No matching member in union\");\n        }\n        default: {\n            return value;\n        }\n    }\n}\nfunction appendPath(opts, path) {\n    return opts?._pathPrefix ? `${opts._pathPrefix}.${path}` : path;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":["file:///D:/github/nakafa.com-main/node_modules/convex-helpers/server/stream.js"],"sourcesContent":["import { convexToJson, compareValues, jsonToConvex } from \"convex/values\";\n//\n// Helper functions\n//\nfunction makeExclusive(boundType) {\n    if (boundType === \"gt\" || boundType === \"gte\") {\n        return \"gt\";\n    }\n    return \"lt\";\n}\n/** Split a range query between two index keys into a series of range queries\n * that should be executed in sequence. This is necessary because Convex only\n * supports range queries of the form\n * q.eq(\"f1\", v).eq(\"f2\", v).lt(\"f3\", v).gt(\"f3\", v).\n * i.e. all fields must be equal except for the last field, which can have\n * two inequalities.\n *\n * For example, the range from >[1, 2, 3] to <=[1, 3, 2] would be split into\n * the following queries:\n * 1. q.eq(\"f1\", 1).eq(\"f2\", 2).gt(\"f3\", 3)\n * 2. q.eq(\"f1\", 1).gt(\"f2\", 2).lt(\"f2\", 3)\n * 3. q.eq(\"f1\", 1).eq(\"f2\", 3).lte(\"f3\", 2)\n */\nfunction splitRange(indexFields, \n// For descending queries, the resulting queries are reversed.\norder, startBound, endBound, startBoundType, endBoundType) {\n    // Three parts to the split:\n    // 1. reduce down from startBound to common prefix\n    // 2. range with common prefix\n    // 3. build back up from common prefix to endBound\n    const commonPrefix = [];\n    while (startBound.length > 0 &&\n        endBound.length > 0 &&\n        compareValues(startBound[0], endBound[0]) === 0) {\n        const indexField = indexFields[0];\n        indexFields = indexFields.slice(1);\n        const eqBound = startBound[0];\n        startBound = startBound.slice(1);\n        endBound = endBound.slice(1);\n        commonPrefix.push([\"eq\", indexField, eqBound]);\n    }\n    const makeCompare = (boundType, key) => {\n        const range = commonPrefix.slice();\n        let i = 0;\n        for (; i < key.length - 1; i++) {\n            range.push([\"eq\", indexFields[i], key[i]]);\n        }\n        if (i < key.length) {\n            range.push([boundType, indexFields[i], key[i]]);\n        }\n        return range;\n    };\n    // Stage 1.\n    const startRanges = [];\n    while (startBound.length > 1) {\n        startRanges.push(makeCompare(startBoundType, startBound));\n        startBoundType = makeExclusive(startBoundType);\n        startBound = startBound.slice(0, -1);\n    }\n    // Stage 3.\n    const endRanges = [];\n    while (endBound.length > 1) {\n        endRanges.push(makeCompare(endBoundType, endBound));\n        endBoundType = makeExclusive(endBoundType);\n        endBound = endBound.slice(0, -1);\n    }\n    endRanges.reverse();\n    // Stage 2.\n    let middleRange;\n    if (endBound.length === 0) {\n        middleRange = makeCompare(startBoundType, startBound);\n    }\n    else if (startBound.length === 0) {\n        middleRange = makeCompare(endBoundType, endBound);\n    }\n    else {\n        const startValue = startBound[0];\n        const endValue = endBound[0];\n        middleRange = commonPrefix.slice();\n        middleRange.push([startBoundType, indexFields[0], startValue]);\n        middleRange.push([endBoundType, indexFields[0], endValue]);\n    }\n    const ranges = [...startRanges, middleRange, ...endRanges];\n    if (order === \"desc\") {\n        ranges.reverse();\n    }\n    return ranges;\n}\nfunction rangeToQuery(range) {\n    return (q) => {\n        for (const [boundType, field, value] of range) {\n            q = q[boundType](field, value);\n        }\n        return q;\n    };\n}\n/**\n * Get the ordered list of fields for a given table's index based on the schema.\n *\n * - For \"by_creation_time\", returns [\"_creationTime\", \"_id\"].\n * - For \"by_id\", returns [\"_id\"].\n * - Otherwise, looks up the named index in the schema and returns its fields\n *   followed by [\"_creationTime\", \"_id\"].\n * e.g. for an index defined like `.index(\"abc\", [\"a\", \"b\"])`,\n * returns [\"a\", \"b\", \"_creationTime\", \"_id\"].\n */\nexport function getIndexFields(table, index, schema) {\n    const indexDescriptor = String(index ?? \"by_creation_time\");\n    if (indexDescriptor === \"by_creation_time\") {\n        return [\"_creationTime\", \"_id\"];\n    }\n    if (indexDescriptor === \"by_id\") {\n        return [\"_id\"];\n    }\n    if (!schema) {\n        throw new Error(\"schema is required to infer index fields\");\n    }\n    const tableInfo = schema.tables[table];\n    const indexInfo = tableInfo.indexes.find((index) => index.indexDescriptor === indexDescriptor);\n    if (!indexInfo) {\n        throw new Error(`Index ${indexDescriptor} not found in table ${table}`);\n    }\n    const fields = indexInfo.fields.slice();\n    fields.push(\"_creationTime\");\n    fields.push(\"_id\");\n    return fields;\n}\nfunction getIndexKey(doc, indexFields) {\n    const key = [];\n    for (const field of indexFields) {\n        let obj = doc;\n        for (const subfield of field.split(\".\")) {\n            obj = obj[subfield];\n        }\n        key.push(obj);\n    }\n    return key;\n}\n/**\n * A \"stream\" is an async iterable of query results, ordered by an index on a table.\n *\n * Use it as you would use `ctx.db`.\n * If using pagination in a reactive query, see the warnings on the `paginator`\n * function. TL;DR: you need to pass in `endCursor` to prevent holes or overlaps\n * between pages.\n *\n * Once you have a stream, you can use `mergeStreams` or `filterStream` to make\n * more streams. Then use `queryStream` to convert it into an OrderedQuery,\n * so you can call `.paginate()`, `.collect()`, etc.\n */\nexport function stream(db, schema) {\n    return new StreamDatabaseReader(db, schema);\n}\n/**\n * A \"QueryStream\" is an async iterable of query results, ordered by indexed fields.\n */\nexport class QueryStream {\n    /// Methods for creating new streams as modifications of the current stream.\n    /**\n     * Create a new stream with a TypeScript filter applied.\n     *\n     * This is similar to `db.query(tableName).filter(predicate)`, but it's more\n     * general because it can call arbitrary TypeScript code, including more\n     * database queries.\n     *\n     * All documents filtered out are still considered \"read\" from the database;\n     * they are just excluded from the output stream.\n     *\n     * In contrast to `filter` from convex-helpers/server/filter, this filterWith\n     * is applied *before* any pagination. That means if the filter excludes a lot\n     * of documents, the `.paginate()` method will read a lot of documents until\n     * it gets as many documents as it wants. If you run into issues with reading\n     * too much data, you can pass `maximumRowsRead` to `paginate()`.\n     */\n    filterWith(predicate) {\n        const order = this.getOrder();\n        return new FlatMapStream(this, async (doc) => {\n            const filtered = (await predicate(doc)) ? doc : null;\n            return new SingletonStream(filtered, order, [], [], []);\n        }, []);\n    }\n    /**\n     * Create a new stream where each element is the result of applying the mapper\n     * function to the elements of the original stream.\n     *\n     * Similar to how [1, 2, 3].map(x => x * 2) => [2, 4, 6]\n     */\n    map(mapper) {\n        const order = this.getOrder();\n        return new FlatMapStream(this, async (doc) => {\n            const mapped = await mapper(doc);\n            return new SingletonStream(mapped, order, [], [], []);\n        }, []);\n    }\n    /**\n     * Similar to flatMap on an array, but iterate over a stream, and the for each\n     * element, iterate over the stream created by the mapper function.\n     *\n     * Ordered by the original stream order, then the mapped stream. Similar to\n     * how [\"a\", \"b\"].flatMap(letter => [letter, letter]) => [\"a\", \"a\", \"b\", \"b\"]\n     *\n     * @param mapper A function that takes a document and returns a new stream.\n     * @param mappedIndexFields The index fields of the streams created by mapper.\n     * @returns A stream of documents returned by the mapper streams,\n     *   grouped by the documents in the original stream.\n     */\n    flatMap(mapper, mappedIndexFields) {\n        normalizeIndexFields(mappedIndexFields);\n        return new FlatMapStream(this, mapper, mappedIndexFields);\n    }\n    /**\n     * Get the first item from the original stream for each distinct value of the\n     * selected index fields.\n     *\n     * e.g. if the stream has an equality filter on `a`, and index fields `[a, b, c]`,\n     * we can do `stream.distinct([\"b\"])` to get a stream of the first item for\n     * each distinct value of `b`.\n     * Similarly, you could do `stream.distinct([\"a\", \"b\"])` with the same result,\n     * or `stream.distinct([\"a\", \"b\", \"c\"])` to get the original stream.\n     *\n     * This stream efficiently skips past items with the same value for the selected\n     * distinct index fields.\n     *\n     * This can be used to perform a loose index scan.\n     */\n    distinct(distinctIndexFields) {\n        return new DistinctStream(this, distinctIndexFields);\n    }\n    /// Implementation of OrderedQuery\n    filter(_predicate) {\n        throw new Error(\"Cannot call .filter() directly on a query stream. Use .filterWith() for filtering or .collect() if you want to convert the stream to an array first.\");\n    }\n    async paginate(opts) {\n        if (opts.numItems === 0) {\n            if (opts.cursor === null) {\n                throw new Error(\".paginate called with cursor of null and 0 for numItems. \" +\n                    \"This is not supported, as null is not a valid continueCursor. \" +\n                    \"Advice: avoid calling paginate entirely in these cases.\");\n            }\n            return {\n                page: [],\n                isDone: false,\n                continueCursor: opts.cursor,\n            };\n        }\n        const order = this.getOrder();\n        let newStartKey = {\n            key: [],\n            inclusive: true,\n        };\n        if (opts.cursor !== null) {\n            newStartKey = {\n                key: deserializeCursor(opts.cursor),\n                inclusive: false,\n            };\n        }\n        let newEndKey = {\n            key: [],\n            inclusive: true,\n        };\n        const maxRowsToRead = opts.maximumRowsRead;\n        const softMaxRowsToRead = opts.numItems + 1;\n        let maxRows = opts.numItems;\n        if (opts.endCursor) {\n            newEndKey = {\n                key: deserializeCursor(opts.endCursor),\n                inclusive: true,\n            };\n            // If there's an endCursor, continue until we get there even if it's more\n            // than numItems.\n            maxRows = undefined;\n        }\n        const newLowerBound = order === \"asc\" ? newStartKey : newEndKey;\n        const newUpperBound = order === \"asc\" ? newEndKey : newStartKey;\n        const narrowStream = this.narrow({\n            lowerBound: newLowerBound.key,\n            lowerBoundInclusive: newLowerBound.inclusive,\n            upperBound: newUpperBound.key,\n            upperBoundInclusive: newUpperBound.inclusive,\n        });\n        const page = [];\n        const indexKeys = [];\n        let hasMore = opts.endCursor && opts.endCursor !== \"[]\";\n        let continueCursor = opts.endCursor ?? \"[]\";\n        for await (const [doc, indexKey] of narrowStream.iterWithKeys()) {\n            if (doc !== null) {\n                page.push(doc);\n            }\n            indexKeys.push(indexKey);\n            if ((maxRows !== undefined && page.length >= maxRows) ||\n                (maxRowsToRead !== undefined && indexKeys.length >= maxRowsToRead)) {\n                hasMore = true;\n                continueCursor = serializeCursor(indexKey);\n                break;\n            }\n        }\n        let pageStatus = undefined;\n        let splitCursor = undefined;\n        if (indexKeys.length === maxRowsToRead) {\n            pageStatus = \"SplitRequired\";\n            splitCursor = indexKeys[Math.floor((indexKeys.length - 1) / 2)];\n        }\n        else if (indexKeys.length >= softMaxRowsToRead) {\n            pageStatus = \"SplitRecommended\";\n            splitCursor = indexKeys[Math.floor((indexKeys.length - 1) / 2)];\n        }\n        return {\n            page,\n            isDone: !hasMore,\n            continueCursor,\n            pageStatus,\n            splitCursor: splitCursor ? serializeCursor(splitCursor) : undefined,\n        };\n    }\n    async collect() {\n        return await this.take(Infinity);\n    }\n    async take(n) {\n        const results = [];\n        for await (const [doc, _] of this.iterWithKeys()) {\n            if (doc === null) {\n                continue;\n            }\n            results.push(doc);\n            if (results.length === n) {\n                break;\n            }\n        }\n        return results;\n    }\n    async unique() {\n        const docs = await this.take(2);\n        if (docs.length === 2) {\n            throw new Error(\"Query is not unique\");\n        }\n        return docs[0] ?? null;\n    }\n    async first() {\n        const docs = await this.take(1);\n        return docs[0] ?? null;\n    }\n    [Symbol.asyncIterator]() {\n        const iterator = this.iterWithKeys()[Symbol.asyncIterator]();\n        return {\n            async next() {\n                const result = await iterator.next();\n                if (result.done) {\n                    return { done: true, value: undefined };\n                }\n                return { done: false, value: result.value[0] };\n            },\n        };\n    }\n}\nexport class StreamDatabaseReader {\n    db;\n    schema;\n    // TODO: support system tables\n    system;\n    constructor(db, schema) {\n        this.db = db;\n        this.schema = schema;\n        this.system = db.system;\n    }\n    query(tableName) {\n        return new StreamQueryInitializer(this, tableName);\n    }\n    get(_id) {\n        throw new Error(\"get() not supported for `paginator`\");\n    }\n    normalizeId(_tableName, _id) {\n        throw new Error(\"normalizeId() not supported for `paginator`.\");\n    }\n}\nexport class StreamableQuery extends QueryStream {\n}\nexport class StreamQueryInitializer extends StreamableQuery {\n    parent;\n    table;\n    constructor(parent, table) {\n        super();\n        this.parent = parent;\n        this.table = table;\n    }\n    fullTableScan() {\n        return this.withIndex(\"by_creation_time\");\n    }\n    withIndex(indexName, indexRange) {\n        const indexFields = getIndexFields(this.table, indexName, this.parent.schema);\n        const q = new ReflectIndexRange(indexFields);\n        if (indexRange) {\n            indexRange(q);\n        }\n        return new StreamQuery(this, indexName, q, indexRange);\n    }\n    withSearchIndex(_indexName, _searchFilter) {\n        throw new Error(\"Cannot paginate withSearchIndex\");\n    }\n    inner() {\n        return this.fullTableScan();\n    }\n    order(order) {\n        return this.inner().order(order);\n    }\n    reflect() {\n        return this.inner().reflect();\n    }\n    iterWithKeys() {\n        return this.inner().iterWithKeys();\n    }\n    getOrder() {\n        return this.inner().getOrder();\n    }\n    getEqualityIndexFilter() {\n        return this.inner().getEqualityIndexFilter();\n    }\n    getIndexFields() {\n        return this.inner().getIndexFields();\n    }\n    narrow(indexBounds) {\n        return this.inner().narrow(indexBounds);\n    }\n}\n// Not to be confused with QueryStream or StreamableQuery.\nexport class StreamQuery extends StreamableQuery {\n    parent;\n    index;\n    q;\n    indexRange;\n    constructor(parent, index, q, indexRange) {\n        super();\n        this.parent = parent;\n        this.index = index;\n        this.q = q;\n        this.indexRange = indexRange;\n    }\n    order(order) {\n        return new OrderedStreamQuery(this, order);\n    }\n    inner() {\n        return this.order(\"asc\");\n    }\n    reflect() {\n        return this.inner().reflect();\n    }\n    iterWithKeys() {\n        return this.inner().iterWithKeys();\n    }\n    getOrder() {\n        return this.inner().getOrder();\n    }\n    getEqualityIndexFilter() {\n        return this.inner().getEqualityIndexFilter();\n    }\n    getIndexFields() {\n        return this.inner().getIndexFields();\n    }\n    narrow(indexBounds) {\n        return this.inner().narrow(indexBounds);\n    }\n}\nexport class OrderedStreamQuery extends StreamableQuery {\n    parent;\n    order;\n    constructor(parent, order) {\n        super();\n        this.parent = parent;\n        this.order = order;\n    }\n    reflect() {\n        return {\n            db: this.parent.parent.parent.db,\n            schema: this.parent.parent.parent.schema,\n            table: this.parent.parent.table,\n            index: this.parent.index,\n            indexFields: this.parent.q.indexFields,\n            order: this.order,\n            bounds: {\n                lowerBound: this.parent.q.lowerBoundIndexKey ?? [],\n                lowerBoundInclusive: this.parent.q.lowerBoundInclusive,\n                upperBound: this.parent.q.upperBoundIndexKey ?? [],\n                upperBoundInclusive: this.parent.q.upperBoundInclusive,\n            },\n            indexRange: this.parent.indexRange,\n        };\n    }\n    /**\n     * inner() is as if you had used ctx.db to construct the query.\n     */\n    inner() {\n        const { db, table, index, order, indexRange } = this.reflect();\n        return db.query(table).withIndex(index, indexRange).order(order);\n    }\n    iterWithKeys() {\n        const { indexFields } = this.reflect();\n        const iterable = this.inner();\n        return {\n            [Symbol.asyncIterator]() {\n                const iterator = iterable[Symbol.asyncIterator]();\n                return {\n                    async next() {\n                        const result = await iterator.next();\n                        if (result.done) {\n                            return { done: true, value: undefined };\n                        }\n                        return {\n                            done: false,\n                            value: [result.value, getIndexKey(result.value, indexFields)],\n                        };\n                    },\n                };\n            },\n        };\n    }\n    getOrder() {\n        return this.order;\n    }\n    getEqualityIndexFilter() {\n        return this.parent.q.equalityIndexFilter;\n    }\n    getIndexFields() {\n        return this.parent.q.indexFields;\n    }\n    narrow(indexBounds) {\n        const { db, table, index, order, bounds, schema } = this.reflect();\n        let maxLowerBound = bounds.lowerBound;\n        let maxLowerBoundInclusive = bounds.lowerBoundInclusive;\n        if (compareKeys({\n            value: indexBounds.lowerBound,\n            kind: indexBounds.lowerBoundInclusive ? \"predecessor\" : \"successor\",\n        }, {\n            value: bounds.lowerBound,\n            kind: bounds.lowerBoundInclusive ? \"predecessor\" : \"successor\",\n        }) > 0) {\n            maxLowerBound = indexBounds.lowerBound;\n            maxLowerBoundInclusive = indexBounds.lowerBoundInclusive;\n        }\n        let minUpperBound = bounds.upperBound;\n        let minUpperBoundInclusive = bounds.upperBoundInclusive;\n        if (compareKeys({\n            value: indexBounds.upperBound,\n            kind: indexBounds.upperBoundInclusive ? \"successor\" : \"predecessor\",\n        }, {\n            value: bounds.upperBound,\n            kind: bounds.upperBoundInclusive ? \"successor\" : \"predecessor\",\n        }) < 0) {\n            minUpperBound = indexBounds.upperBound;\n            minUpperBoundInclusive = indexBounds.upperBoundInclusive;\n        }\n        return streamIndexRange(db, schema, table, index, {\n            lowerBound: maxLowerBound,\n            lowerBoundInclusive: maxLowerBoundInclusive,\n            upperBound: minUpperBound,\n            upperBoundInclusive: minUpperBoundInclusive,\n        }, order);\n    }\n}\n/**\n * Create a stream of documents using the given index and bounds.\n */\nexport function streamIndexRange(db, schema, table, index, bounds, order) {\n    const indexFields = getIndexFields(table, index, schema);\n    const splitBounds = splitRange(indexFields, order, bounds.lowerBound, bounds.upperBound, bounds.lowerBoundInclusive ? \"gte\" : \"gt\", bounds.upperBoundInclusive ? \"lte\" : \"lt\");\n    const subQueries = splitBounds.map((splitBound) => stream(db, schema)\n        .query(table)\n        .withIndex(index, rangeToQuery(splitBound))\n        .order(order));\n    return new ConcatStreams(...subQueries);\n}\nclass ReflectIndexRange {\n    indexFields;\n    #hasSuffix = false;\n    lowerBoundIndexKey = undefined;\n    lowerBoundInclusive = true;\n    upperBoundIndexKey = undefined;\n    upperBoundInclusive = true;\n    equalityIndexFilter = [];\n    constructor(indexFields) {\n        this.indexFields = indexFields;\n    }\n    eq(field, value) {\n        if (!this.#canLowerBound(field) || !this.#canUpperBound(field)) {\n            throw new Error(`Cannot use eq on field '${field}'`);\n        }\n        this.lowerBoundIndexKey = this.lowerBoundIndexKey ?? [];\n        this.lowerBoundIndexKey.push(value);\n        this.upperBoundIndexKey = this.upperBoundIndexKey ?? [];\n        this.upperBoundIndexKey.push(value);\n        this.equalityIndexFilter.push(value);\n        return this;\n    }\n    lt(field, value) {\n        if (!this.#canUpperBound(field)) {\n            throw new Error(`Cannot use lt on field '${field}'`);\n        }\n        this.upperBoundIndexKey = this.upperBoundIndexKey ?? [];\n        this.upperBoundIndexKey.push(value);\n        this.upperBoundInclusive = false;\n        this.#hasSuffix = true;\n        return this;\n    }\n    lte(field, value) {\n        if (!this.#canUpperBound(field)) {\n            throw new Error(`Cannot use lte on field '${field}'`);\n        }\n        this.upperBoundIndexKey = this.upperBoundIndexKey ?? [];\n        this.upperBoundIndexKey.push(value);\n        this.#hasSuffix = true;\n        return this;\n    }\n    gt(field, value) {\n        if (!this.#canLowerBound(field)) {\n            throw new Error(`Cannot use gt on field '${field}'`);\n        }\n        this.lowerBoundIndexKey = this.lowerBoundIndexKey ?? [];\n        this.lowerBoundIndexKey.push(value);\n        this.lowerBoundInclusive = false;\n        this.#hasSuffix = true;\n        return this;\n    }\n    gte(field, value) {\n        if (!this.#canLowerBound(field)) {\n            throw new Error(`Cannot use gte on field '${field}'`);\n        }\n        this.lowerBoundIndexKey = this.lowerBoundIndexKey ?? [];\n        this.lowerBoundIndexKey.push(value);\n        this.#hasSuffix = true;\n        return this;\n    }\n    #canLowerBound(field) {\n        const currentLowerBoundLength = this.lowerBoundIndexKey?.length ?? 0;\n        const currentUpperBoundLength = this.upperBoundIndexKey?.length ?? 0;\n        if (currentLowerBoundLength > currentUpperBoundLength) {\n            // Already have a lower bound.\n            return false;\n        }\n        if (currentLowerBoundLength === currentUpperBoundLength &&\n            this.#hasSuffix) {\n            // Already have a lower bound and an upper bound.\n            return false;\n        }\n        return (currentLowerBoundLength < this.indexFields.length &&\n            this.indexFields[currentLowerBoundLength] === field);\n    }\n    #canUpperBound(field) {\n        const currentLowerBoundLength = this.lowerBoundIndexKey?.length ?? 0;\n        const currentUpperBoundLength = this.upperBoundIndexKey?.length ?? 0;\n        if (currentUpperBoundLength > currentLowerBoundLength) {\n            // Already have an upper bound.\n            return false;\n        }\n        if (currentLowerBoundLength === currentUpperBoundLength &&\n            this.#hasSuffix) {\n            // Already have a lower bound and an upper bound.\n            return false;\n        }\n        return (currentUpperBoundLength < this.indexFields.length &&\n            this.indexFields[currentUpperBoundLength] === field);\n    }\n}\n/**\n * Merge multiple streams, provided in any order, into a single stream.\n *\n * The streams will be merged into a stream of documents ordered by the index keys,\n * i.e. by \"author\" (then by the implicit \"_creationTime\").\n *\n * e.g. ```ts\n * mergedStream([\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user3\")),\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user1\")),\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user2\")),\n * ], [\"author\"])\n * ```\n *\n * returns a stream of messages for user1, then user2, then user3.\n *\n * You can also use `orderByIndexFields` to change the indexed fields before merging, which changes the order of the merged stream.\n * This only works if the streams are already ordered by `orderByIndexFields`,\n * which happens if each does a .eq(field, value) on all index fields before `orderByIndexFields`.\n *\n * e.g. if the \"by_author\" index is defined as being ordered by [\"author\", \"_creationTime\"],\n * and each query does an equality lookup on \"author\", each individual query before merging is in fact ordered by \"_creationTime\".\n *\n * e.g. ```ts\n * mergedStream([\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user3\")),\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user1\")),\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user2\")),\n * ], [\"_creationTime\"])\n * ```\n *\n * This returns a stream of messages from all three users, sorted by creation time.\n */\nexport function mergedStream(streams, orderByIndexFields) {\n    return new MergedStream(streams, orderByIndexFields);\n}\nexport class MergedStream extends QueryStream {\n    #order;\n    #streams;\n    #equalityIndexFilter;\n    #indexFields;\n    constructor(streams, orderByIndexFields) {\n        super();\n        if (streams.length === 0) {\n            throw new Error(\"Cannot union empty array of streams\");\n        }\n        this.#order = allSame(streams.map((stream) => stream.getOrder()), \"Cannot merge streams with different orders\");\n        this.#streams = streams.map((stream) => new OrderByStream(stream, orderByIndexFields));\n        this.#indexFields = allSame(this.#streams.map((stream) => stream.getIndexFields()), \"Cannot merge streams with different index fields. Consider using .orderBy()\");\n        // Calculate common prefix of equality index filters.\n        this.#equalityIndexFilter = commonPrefix(this.#streams.map((stream) => stream.getEqualityIndexFilter()));\n    }\n    iterWithKeys() {\n        const iterables = this.#streams.map((stream) => stream.iterWithKeys());\n        const comparisonInversion = this.#order === \"asc\" ? 1 : -1;\n        return {\n            [Symbol.asyncIterator]() {\n                const iterators = iterables.map((iterable) => iterable[Symbol.asyncIterator]());\n                const results = Array.from({ length: iterators.length }, () => ({\n                    done: false,\n                    value: undefined,\n                }));\n                return {\n                    async next() {\n                        // Fill results from iterators with no value yet.\n                        await Promise.all(iterators.map(async (iterator, i) => {\n                            if (!results[i].done && !results[i].value) {\n                                const result = await iterator.next();\n                                results[i] = result;\n                            }\n                        }));\n                        // Find index for the value with the lowest index key.\n                        let minIndexKeyAndIndex = undefined;\n                        for (let i = 0; i < results.length; i++) {\n                            const result = results[i];\n                            if (result.done || !result.value) {\n                                continue;\n                            }\n                            const [_, resultIndexKey] = result.value;\n                            if (minIndexKeyAndIndex === undefined) {\n                                minIndexKeyAndIndex = [resultIndexKey, i];\n                                continue;\n                            }\n                            const [prevMin, _prevMinIndex] = minIndexKeyAndIndex;\n                            if (compareKeys({ value: resultIndexKey, kind: \"exact\" }, { value: prevMin, kind: \"exact\" }) *\n                                comparisonInversion <\n                                0) {\n                                minIndexKeyAndIndex = [resultIndexKey, i];\n                            }\n                        }\n                        if (minIndexKeyAndIndex === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const [_, minIndex] = minIndexKeyAndIndex;\n                        const result = results[minIndex].value;\n                        // indicate that we've used this result\n                        results[minIndex].value = undefined;\n                        return { done: false, value: result };\n                    },\n                };\n            },\n        };\n    }\n    getOrder() {\n        return this.#order;\n    }\n    getEqualityIndexFilter() {\n        return this.#equalityIndexFilter;\n    }\n    getIndexFields() {\n        return this.#indexFields;\n    }\n    narrow(indexBounds) {\n        return new MergedStream(this.#streams.map((stream) => stream.narrow(indexBounds)), this.#indexFields);\n    }\n}\nfunction allSame(values, errorMessage) {\n    const first = values[0];\n    for (const value of values) {\n        if (compareValues(value, first)) {\n            throw new Error(errorMessage);\n        }\n    }\n    return first;\n}\nfunction commonPrefix(values) {\n    let commonPrefix = values[0];\n    for (const value of values) {\n        for (let i = 0; i < commonPrefix.length; i++) {\n            if (i >= value.length || compareValues(commonPrefix[i], value[i])) {\n                commonPrefix = commonPrefix.slice(0, i);\n                break;\n            }\n        }\n    }\n    return commonPrefix;\n}\n/**\n * Concatenate multiple streams into a single stream.\n * This assumes that the streams correspond to disjoint index ranges,\n * and are provided in the same order as the index ranges.\n *\n * e.g. ```ts\n * new ConcatStreams(\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user1\")),\n *   stream(db, schema).query(\"messages\").withIndex(\"by_author\", q => q.eq(\"author\", \"user2\")),\n * )\n * ```\n *\n * is valid, but if the stream arguments were reversed, or the queries were\n * `.order(\"desc\")`, it would be invalid.\n *\n * It's not recommended to use `ConcatStreams` directly, since it has the same\n * behavior as `MergedStream`, but with fewer runtime checks.\n */\nclass ConcatStreams extends QueryStream {\n    #order;\n    #streams;\n    #equalityIndexFilter;\n    #indexFields;\n    constructor(...streams) {\n        super();\n        this.#streams = streams;\n        if (streams.length === 0) {\n            throw new Error(\"Cannot concat empty array of streams\");\n        }\n        this.#order = allSame(streams.map((stream) => stream.getOrder()), \"Cannot concat streams with different orders. Consider using .orderBy()\");\n        this.#indexFields = allSame(streams.map((stream) => stream.getIndexFields()), \"Cannot concat streams with different index fields. Consider using .orderBy()\");\n        this.#equalityIndexFilter = commonPrefix(streams.map((stream) => stream.getEqualityIndexFilter()));\n    }\n    iterWithKeys() {\n        const iterables = this.#streams.map((stream) => stream.iterWithKeys());\n        const comparisonInversion = this.#order === \"asc\" ? 1 : -1;\n        let previousIndexKey = undefined;\n        return {\n            [Symbol.asyncIterator]() {\n                const iterators = iterables.map((iterable) => iterable[Symbol.asyncIterator]());\n                return {\n                    async next() {\n                        while (iterators.length > 0) {\n                            const result = await iterators[0].next();\n                            if (result.done) {\n                                iterators.shift();\n                            }\n                            else {\n                                const [_, indexKey] = result.value;\n                                if (previousIndexKey !== undefined &&\n                                    compareKeys({\n                                        value: previousIndexKey,\n                                        kind: \"exact\",\n                                    }, {\n                                        value: indexKey,\n                                        kind: \"exact\",\n                                    }) *\n                                        comparisonInversion >\n                                        0) {\n                                    throw new Error(`ConcatStreams in wrong order: ${JSON.stringify(previousIndexKey)}, ${JSON.stringify(indexKey)}`);\n                                }\n                                previousIndexKey = indexKey;\n                                return result;\n                            }\n                        }\n                        return { done: true, value: undefined };\n                    },\n                };\n            },\n        };\n    }\n    getOrder() {\n        return this.#order;\n    }\n    getEqualityIndexFilter() {\n        return this.#equalityIndexFilter;\n    }\n    getIndexFields() {\n        return this.#indexFields;\n    }\n    narrow(indexBounds) {\n        return new ConcatStreams(...this.#streams.map((stream) => stream.narrow(indexBounds)));\n    }\n}\nclass FlatMapStreamIterator {\n    #outerStream;\n    #outerIterator;\n    #currentOuterItem = null;\n    #mapper;\n    #mappedIndexFields;\n    constructor(outerStream, mapper, mappedIndexFields) {\n        this.#outerIterator = outerStream.iterWithKeys()[Symbol.asyncIterator]();\n        this.#outerStream = outerStream;\n        this.#mapper = mapper;\n        this.#mappedIndexFields = mappedIndexFields;\n    }\n    singletonSkipInnerStream() {\n        // If the outer stream is a filtered value, yield a singleton\n        // filtered value from the inner stream, with index key of nulls.\n        const indexKey = this.#mappedIndexFields.map(() => null);\n        return new SingletonStream(null, this.#outerStream.getOrder(), this.#mappedIndexFields, indexKey, indexKey);\n    }\n    async setCurrentOuterItem(item) {\n        const [t, indexKey] = item;\n        let innerStream;\n        if (t === null) {\n            innerStream = this.singletonSkipInnerStream();\n        }\n        else {\n            innerStream = await this.#mapper(t);\n            if (!equalIndexFields(innerStream.getIndexFields(), this.#mappedIndexFields)) {\n                throw new Error(`FlatMapStream: inner stream has different index fields than expected: ${JSON.stringify(innerStream.getIndexFields())} vs ${JSON.stringify(this.#mappedIndexFields)}`);\n            }\n            if (innerStream.getOrder() !== this.#outerStream.getOrder()) {\n                throw new Error(`FlatMapStream: inner stream has different order than outer stream: ${innerStream.getOrder()} vs ${this.#outerStream.getOrder()}`);\n            }\n        }\n        this.#currentOuterItem = {\n            t,\n            indexKey,\n            innerIterator: innerStream.iterWithKeys()[Symbol.asyncIterator](),\n            count: 0,\n        };\n    }\n    async next() {\n        if (this.#currentOuterItem === null) {\n            const result = await this.#outerIterator.next();\n            if (result.done) {\n                return { done: true, value: undefined };\n            }\n            await this.setCurrentOuterItem(result.value);\n            return await this.next();\n        }\n        const result = await this.#currentOuterItem.innerIterator.next();\n        if (result.done) {\n            if (this.#currentOuterItem.count > 0) {\n                this.#currentOuterItem = null;\n            }\n            else {\n                // The inner stream was completely empty, so we should inject a null\n                // (which will be skipped by everything except the maximumRowsRead count)\n                // to account for the cost of the outer stream.\n                this.#currentOuterItem.innerIterator = this.singletonSkipInnerStream()\n                    .iterWithKeys()[Symbol.asyncIterator]();\n            }\n            return await this.next();\n        }\n        const [u, indexKey] = result.value;\n        this.#currentOuterItem.count++;\n        const fullIndexKey = [...this.#currentOuterItem.indexKey, ...indexKey];\n        return { done: false, value: [u, fullIndexKey] };\n    }\n}\nclass FlatMapStream extends QueryStream {\n    #stream;\n    #mapper;\n    #mappedIndexFields;\n    constructor(stream, mapper, mappedIndexFields) {\n        super();\n        this.#stream = stream;\n        this.#mapper = mapper;\n        this.#mappedIndexFields = mappedIndexFields;\n    }\n    iterWithKeys() {\n        const outerStream = this.#stream;\n        const mapper = this.#mapper;\n        const mappedIndexFields = this.#mappedIndexFields;\n        return {\n            [Symbol.asyncIterator]() {\n                return new FlatMapStreamIterator(outerStream, mapper, mappedIndexFields);\n            },\n        };\n    }\n    getOrder() {\n        return this.#stream.getOrder();\n    }\n    getEqualityIndexFilter() {\n        return this.#stream.getEqualityIndexFilter();\n    }\n    getIndexFields() {\n        return [...this.#stream.getIndexFields(), ...this.#mappedIndexFields];\n    }\n    narrow(indexBounds) {\n        const outerLength = this.#stream.getIndexFields().length;\n        const outerLowerBound = indexBounds.lowerBound.slice(0, outerLength);\n        const outerUpperBound = indexBounds.upperBound.slice(0, outerLength);\n        const innerLowerBound = indexBounds.lowerBound.slice(outerLength);\n        const innerUpperBound = indexBounds.upperBound.slice(outerLength);\n        const outerIndexBounds = {\n            lowerBound: outerLowerBound,\n            lowerBoundInclusive: innerLowerBound.length === 0 ? indexBounds.lowerBoundInclusive : true,\n            upperBound: outerUpperBound,\n            upperBoundInclusive: innerUpperBound.length === 0 ? indexBounds.upperBoundInclusive : true,\n        };\n        const innerIndexBounds = {\n            lowerBound: innerLowerBound,\n            lowerBoundInclusive: innerLowerBound.length === 0 ? true : indexBounds.lowerBoundInclusive,\n            upperBound: innerUpperBound,\n            upperBoundInclusive: innerUpperBound.length === 0 ? true : indexBounds.upperBoundInclusive,\n        };\n        return new FlatMapStream(this.#stream.narrow(outerIndexBounds), async (t) => {\n            const innerStream = await this.#mapper(t);\n            return innerStream.narrow(innerIndexBounds);\n        }, this.#mappedIndexFields);\n    }\n}\nexport class SingletonStream extends QueryStream {\n    #value;\n    #order;\n    #indexFields;\n    #indexKey;\n    #equalityIndexFilter;\n    constructor(value, order = \"asc\", indexFields, indexKey, equalityIndexFilter) {\n        super();\n        this.#value = value;\n        this.#order = order;\n        this.#indexFields = indexFields;\n        this.#indexKey = indexKey;\n        this.#equalityIndexFilter = equalityIndexFilter;\n        if (indexKey.length !== indexFields.length) {\n            throw new Error(`indexKey must have the same length as indexFields: ${JSON.stringify(indexKey)} vs ${JSON.stringify(indexFields)}`);\n        }\n    }\n    iterWithKeys() {\n        const value = this.#value;\n        const indexKey = this.#indexKey;\n        return {\n            [Symbol.asyncIterator]() {\n                let sent = false;\n                return {\n                    async next() {\n                        if (sent) {\n                            return { done: true, value: undefined };\n                        }\n                        sent = true;\n                        return { done: false, value: [value, indexKey] };\n                    },\n                };\n            },\n        };\n    }\n    getOrder() {\n        return this.#order;\n    }\n    getIndexFields() {\n        return this.#indexFields;\n    }\n    getEqualityIndexFilter() {\n        return this.#equalityIndexFilter;\n    }\n    narrow(indexBounds) {\n        const compareLowerBound = compareKeys({\n            value: indexBounds.lowerBound,\n            kind: indexBounds.lowerBoundInclusive ? \"exact\" : \"successor\",\n        }, {\n            value: this.#indexKey,\n            kind: \"exact\",\n        });\n        const compareUpperBound = compareKeys({\n            value: this.#indexKey,\n            kind: \"exact\",\n        }, {\n            value: indexBounds.upperBound,\n            kind: indexBounds.upperBoundInclusive ? \"exact\" : \"predecessor\",\n        });\n        // If lowerBound <= this.indexKey <= upperBound, return this.value\n        if (compareLowerBound <= 0 && compareUpperBound <= 0) {\n            return new SingletonStream(this.#value, this.#order, this.#indexFields, this.#indexKey, this.#equalityIndexFilter);\n        }\n        return new EmptyStream(this.#order, this.#indexFields);\n    }\n}\n/**\n * This is a completely empty stream that yields no values, and in particular\n * does not count towards maximumRowsRead.\n * Compare to SingletonStream(null, ...), which yields no values but does count\n * towards maximumRowsRead.\n */\nexport class EmptyStream extends QueryStream {\n    #order;\n    #indexFields;\n    constructor(order, indexFields) {\n        super();\n        this.#order = order;\n        this.#indexFields = indexFields;\n    }\n    iterWithKeys() {\n        return {\n            [Symbol.asyncIterator]() {\n                return {\n                    async next() {\n                        return { done: true, value: undefined };\n                    },\n                };\n            },\n        };\n    }\n    getOrder() {\n        return this.#order;\n    }\n    getIndexFields() {\n        return this.#indexFields;\n    }\n    getEqualityIndexFilter() {\n        return [];\n    }\n    narrow(_indexBounds) {\n        return this;\n    }\n}\nfunction normalizeIndexFields(indexFields) {\n    // Append _creationTime and _id to the index fields if they're not already there\n    if (!indexFields.includes(\"_creationTime\")) {\n        // With one exception: if indexFields is [\"_id\"], we don't need to add _creationTime\n        if (indexFields.length !== 1 || indexFields[0] !== \"_id\") {\n            indexFields.push(\"_creationTime\");\n        }\n    }\n    if (!indexFields.includes(\"_id\")) {\n        indexFields.push(\"_id\");\n    }\n}\n// Given a stream ordered by `indexFields`, where the first `equalityIndexLength`\n// fields are bounded by equality filters, return a generator of the possible\n// index fields used for ordering.\nfunction* getOrderingIndexFields(stream) {\n    const streamEqualityIndexLength = stream.getEqualityIndexFilter().length;\n    const streamIndexFields = stream.getIndexFields();\n    for (let i = 0; i <= streamEqualityIndexLength; i++) {\n        yield streamIndexFields.slice(i);\n    }\n}\nclass OrderByStream extends QueryStream {\n    #staticFilter;\n    #stream;\n    #indexFields;\n    constructor(stream, indexFields) {\n        super();\n        this.#stream = stream;\n        this.#indexFields = indexFields;\n        normalizeIndexFields(this.#indexFields);\n        // indexFields must be a suffix of the stream's index fields, and include\n        // all of the non-equality index fields.\n        const streamIndexFields = stream.getIndexFields();\n        const orderingIndexFields = Array.from(getOrderingIndexFields(stream));\n        if (!orderingIndexFields.some((orderingIndexFields) => equalIndexFields(orderingIndexFields, indexFields))) {\n            throw new Error(`indexFields must be some sequence of fields the stream is ordered by: ${JSON.stringify(indexFields)}, ${JSON.stringify(streamIndexFields)} (${stream.getEqualityIndexFilter().length} equality fields)`);\n        }\n        this.#staticFilter = stream\n            .getEqualityIndexFilter()\n            .slice(0, streamIndexFields.length - indexFields.length);\n    }\n    getOrder() {\n        return this.#stream.getOrder();\n    }\n    getEqualityIndexFilter() {\n        return this.#stream\n            .getEqualityIndexFilter()\n            .slice(this.#staticFilter.length);\n    }\n    getIndexFields() {\n        return this.#indexFields;\n    }\n    iterWithKeys() {\n        const iterable = this.#stream.iterWithKeys();\n        const staticFilter = this.#staticFilter;\n        return {\n            [Symbol.asyncIterator]() {\n                const iterator = iterable[Symbol.asyncIterator]();\n                return {\n                    async next() {\n                        const result = await iterator.next();\n                        if (result.done) {\n                            return result;\n                        }\n                        const [doc, indexKey] = result.value;\n                        return {\n                            done: false,\n                            value: [doc, indexKey.slice(staticFilter.length)],\n                        };\n                    },\n                };\n            },\n        };\n    }\n    narrow(indexBounds) {\n        return new OrderByStream(this.#stream.narrow({\n            lowerBound: [...this.#staticFilter, ...indexBounds.lowerBound],\n            lowerBoundInclusive: indexBounds.lowerBoundInclusive,\n            upperBound: [...this.#staticFilter, ...indexBounds.upperBound],\n            upperBoundInclusive: indexBounds.upperBoundInclusive,\n        }), this.#indexFields);\n    }\n}\nclass DistinctStream extends QueryStream {\n    #distinctIndexFieldsLength;\n    #stream;\n    #distinctIndexFields;\n    constructor(stream, distinctIndexFields) {\n        super();\n        this.#stream = stream;\n        this.#distinctIndexFields = distinctIndexFields;\n        // distinctIndexFields must be a prefix of the stream's ordering index fields\n        let distinctIndexFieldsLength = undefined;\n        for (const orderingIndexFields of getOrderingIndexFields(stream)) {\n            const prefix = orderingIndexFields.slice(0, distinctIndexFields.length);\n            if (equalIndexFields(prefix, distinctIndexFields)) {\n                const equalityLength = stream.getIndexFields().length - orderingIndexFields.length;\n                distinctIndexFieldsLength = equalityLength + distinctIndexFields.length;\n                break;\n            }\n        }\n        if (distinctIndexFieldsLength === undefined) {\n            throw new Error(`distinctIndexFields must be a prefix of the stream's ordering index fields: ${JSON.stringify(distinctIndexFields)}, ${JSON.stringify(stream.getIndexFields())} (${stream.getEqualityIndexFilter().length} equality fields)`);\n        }\n        this.#distinctIndexFieldsLength = distinctIndexFieldsLength;\n    }\n    iterWithKeys() {\n        const stream = this.#stream;\n        const distinctIndexFieldsLength = this.#distinctIndexFieldsLength;\n        return {\n            [Symbol.asyncIterator]() {\n                let currentStream = stream;\n                let currentIterator = currentStream\n                    .iterWithKeys()[Symbol.asyncIterator]();\n                return {\n                    async next() {\n                        const result = await currentIterator.next();\n                        if (result.done) {\n                            return { done: true, value: undefined };\n                        }\n                        const [doc, indexKey] = result.value;\n                        if (doc === null) {\n                            // If the original stream has a post-filter `.filterWith`, we will\n                            // iterate over filtered items -- possibly many with the same set of\n                            // distinct index fields -- before finding the first item for the set\n                            // of distinct index fields.\n                            // So it's recommended to put `.filterWith` after `.distinct`.\n                            return { done: false, value: [null, indexKey] };\n                        }\n                        const distinctIndexKey = indexKey.slice(0, distinctIndexFieldsLength);\n                        if (stream.getOrder() === \"asc\") {\n                            currentStream = currentStream.narrow({\n                                lowerBound: distinctIndexKey,\n                                lowerBoundInclusive: false,\n                                upperBound: [],\n                                upperBoundInclusive: true,\n                            });\n                        }\n                        else {\n                            currentStream = currentStream.narrow({\n                                lowerBound: [],\n                                lowerBoundInclusive: true,\n                                upperBound: distinctIndexKey,\n                                upperBoundInclusive: false,\n                            });\n                        }\n                        currentIterator = currentStream\n                            .iterWithKeys()[Symbol.asyncIterator]();\n                        return result;\n                    },\n                };\n            },\n        };\n    }\n    narrow(indexBounds) {\n        const indexBoundsPrefix = {\n            ...indexBounds,\n            lowerBound: indexBounds.lowerBound.slice(0, this.#distinctIndexFieldsLength),\n            upperBound: indexBounds.upperBound.slice(0, this.#distinctIndexFieldsLength),\n        };\n        return new DistinctStream(this.#stream.narrow(indexBoundsPrefix), this.#distinctIndexFields);\n    }\n    getOrder() {\n        return this.#stream.getOrder();\n    }\n    getIndexFields() {\n        return this.#stream.getIndexFields();\n    }\n    getEqualityIndexFilter() {\n        return this.#stream.getEqualityIndexFilter();\n    }\n}\nfunction equalIndexFields(indexFields1, indexFields2) {\n    if (indexFields1.length !== indexFields2.length) {\n        return false;\n    }\n    for (let i = 0; i < indexFields1.length; i++) {\n        if (indexFields1[i] !== indexFields2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getValueAtIndex(v, index) {\n    if (index >= v.length) {\n        return undefined;\n    }\n    return { kind: \"found\", value: v[index] };\n}\nfunction compareDanglingSuffix(shorterKeyKind, longerKeyKind, shorterKey, longerKey) {\n    if (shorterKeyKind === \"exact\" && longerKeyKind === \"exact\") {\n        throw new Error(`Exact keys are not the same length:  ${JSON.stringify(shorterKey.value)}, ${JSON.stringify(longerKey.value)}`);\n    }\n    if (shorterKeyKind === \"exact\") {\n        throw new Error(`Exact key is shorter than prefix: ${JSON.stringify(shorterKey.value)}, ${JSON.stringify(longerKey.value)}`);\n    }\n    if (shorterKeyKind === \"predecessor\" && longerKeyKind === \"successor\") {\n        // successor is longer than predecessor, so it is bigger\n        return -1;\n    }\n    if (shorterKeyKind === \"successor\" && longerKeyKind === \"predecessor\") {\n        // successor is shorter than predecessor, so it is larger\n        return 1;\n    }\n    if (shorterKeyKind === \"predecessor\" && longerKeyKind === \"predecessor\") {\n        // predecessor of [2, 3] contains [2, 1] while predecessor of [2] doesn't, so longer predecessors are larger\n        return -1;\n    }\n    if (shorterKeyKind === \"successor\" && longerKeyKind === \"successor\") {\n        // successor of [2, 3] contains [2, 4] while successor of [2] doesn't, so longer successors are smaller\n        return 1;\n    }\n    if (shorterKeyKind === \"predecessor\" && longerKeyKind === \"exact\") {\n        return -1;\n    }\n    if (shorterKeyKind === \"successor\" && longerKeyKind === \"exact\") {\n        return 1;\n    }\n    throw new Error(`Unexpected key kinds: ${shorterKeyKind}, ${longerKeyKind}`);\n}\nfunction compareKeys(key1, key2) {\n    let i = 0;\n    while (i < Math.max(key1.value.length, key2.value.length)) {\n        const v1 = getValueAtIndex(key1.value, i);\n        const v2 = getValueAtIndex(key2.value, i);\n        if (v1 === undefined) {\n            return compareDanglingSuffix(key1.kind, key2.kind, key1, key2);\n        }\n        if (v2 === undefined) {\n            return -1 * compareDanglingSuffix(key2.kind, key1.kind, key2, key1);\n        }\n        const result = compareValues(v1.value, v2.value);\n        if (result !== 0) {\n            return result;\n        }\n        // if the prefixes are the same so far, keep going with the comparison\n        i++;\n    }\n    if (key1.kind === key2.kind) {\n        return 0;\n    }\n    // keys are the same length and values\n    if (key1.kind === \"exact\") {\n        if (key2.kind === \"successor\") {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n    if (key1.kind === \"predecessor\") {\n        return -1;\n    }\n    if (key1.kind === \"successor\") {\n        return 1;\n    }\n    // Note: we're being cautious here, but we aren't checking above that the type\n    // of key2.kind is valid...\n    throw new Error(`Unexpected key kind: ${key1.kind}`);\n}\nfunction serializeCursor(key) {\n    return JSON.stringify(convexToJson(key.map((v) => v === undefined\n        ? \"undefined\"\n        : typeof v === \"string\" && v.endsWith(\"undefined\")\n            ? // in the unlikely case their string was \"undefined\"\n                // or \"_undefined\" etc, we escape it.\n                \"_\" + v\n            : v)));\n}\nfunction deserializeCursor(cursor) {\n    return jsonToConvex(JSON.parse(cursor)).map((v) => {\n        if (typeof v === \"string\") {\n            if (v === \"undefined\") {\n                // This is a special case for the undefined value.\n                // It's not a valid value in the index, but it's a valid value in the\n                // cursor.\n                return undefined;\n            }\n            if (v.endsWith(\"undefined\")) {\n                // in the unlikely case their string was \"undefined\" it was changed to\n                // \"_undefined\" in the serialization process.\n                // NB: if their string was \"_undefined\" it was changed to\n                // \"__undefined\" in the serialization process, and so on.\n                return v.slice(1);\n            }\n        }\n        return v;\n    });\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2120, "column": 0}, "map": {"version":3,"sources":["file:///D:/github/nakafa.com-main/node_modules/convex-helpers/server/cors.js"],"sourcesContent":["/**\n * This file defines a CorsHttpRouter class that extends Convex's HttpRouter.\n * It provides CORS (Cross-Origin Resource Sharing) support for HTTP routes.\n *\n * The CorsHttpRouter:\n * 1. Allows specifying allowed origins for CORS.\n * 2. Overrides the route method to add CORS headers to all non-OPTIONS requests.\n * 3. Automatically adds an OPTIONS route to handle CORS preflight requests.\n * 4. Uses the handleCors helper function to apply CORS headers consistently.\n *\n * This router simplifies the process of making Convex HTTP endpoints\n * accessible to web applications hosted on different domains while\n * maintaining proper CORS configuration.\n */\nimport { httpActionGeneric, httpRouter, HttpRouter, ROUTABLE_HTTP_METHODS, } from \"convex/server\";\nexport const DEFAULT_EXPOSED_HEADERS = [\n    // For Range requests\n    \"Content-Range\",\n    \"Accept-Ranges\",\n];\n/**\n * Factory function to create a router that adds CORS support to routes.\n * @param allowedOrigins An array of allowed origins for CORS.\n * @returns A function to use instead of http.route when you want CORS.\n */\nexport const corsRouter = (http, corsConfig) => {\n    const allowedExactMethodsByPath = new Map();\n    const allowedPrefixMethodsByPath = new Map();\n    return {\n        http,\n        route: (routeSpec) => {\n            const tempRouter = httpRouter();\n            tempRouter.exactRoutes = http.exactRoutes;\n            tempRouter.prefixRoutes = http.prefixRoutes;\n            const config = {\n                ...corsConfig,\n                ...routeSpec,\n            };\n            const httpCorsHandler = handleCors({\n                originalHandler: routeSpec.handler,\n                allowedMethods: [routeSpec.method],\n                ...config,\n            });\n            /**\n             * Figure out what kind of route we're adding: exact or prefix and handle\n             * accordingly.\n             */\n            if (\"path\" in routeSpec) {\n                let methods = allowedExactMethodsByPath.get(routeSpec.path);\n                if (!methods) {\n                    methods = new Set();\n                    allowedExactMethodsByPath.set(routeSpec.path, methods);\n                }\n                methods.add(routeSpec.method);\n                tempRouter.route({\n                    path: routeSpec.path,\n                    method: routeSpec.method,\n                    handler: httpCorsHandler,\n                });\n                handleExactRoute(tempRouter, routeSpec, config, Array.from(methods));\n            }\n            else {\n                let methods = allowedPrefixMethodsByPath.get(routeSpec.pathPrefix);\n                if (!methods) {\n                    methods = new Set();\n                    allowedPrefixMethodsByPath.set(routeSpec.pathPrefix, methods);\n                }\n                methods.add(routeSpec.method);\n                tempRouter.route({\n                    pathPrefix: routeSpec.pathPrefix,\n                    method: routeSpec.method,\n                    handler: httpCorsHandler,\n                });\n                handlePrefixRoute(tempRouter, routeSpec, config, Array.from(methods));\n            }\n            /**\n             * Copy the routes from the temporary router to the main router.\n             */\n            http.exactRoutes = new Map(tempRouter.exactRoutes);\n            http.prefixRoutes = new Map(tempRouter.prefixRoutes);\n        },\n    };\n};\n/**\n * Handles exact route matching and adds OPTIONS handler.\n * @param tempRouter Temporary router instance.\n * @param routeSpec Route specification for exact matching.\n */\nfunction handleExactRoute(tempRouter, routeSpec, config, allowedMethods) {\n    const currentMethodsForPath = tempRouter.exactRoutes.get(routeSpec.path);\n    /**\n     * Add the OPTIONS handler for the given path\n     */\n    const optionsHandler = createOptionsHandlerForMethods(allowedMethods, config);\n    currentMethodsForPath?.set(\"OPTIONS\", optionsHandler);\n    tempRouter.exactRoutes.set(routeSpec.path, new Map(currentMethodsForPath));\n}\n/**\n * Handles prefix route matching and adds OPTIONS handler.\n * @param tempRouter Temporary router instance.\n * @param routeSpec Route specification for prefix matching.\n */\nfunction handlePrefixRoute(tempRouter, routeSpec, config, allowedMethods) {\n    /**\n     * prefixRoutes is structured differently than exactRoutes. It's defined as\n     * a Map<string, Map<string, PublicHttpAction>> where the KEY is the\n     * METHOD and the VALUE is a map of paths and handlers.\n     */\n    const optionsHandler = createOptionsHandlerForMethods(allowedMethods, config);\n    const optionsPrefixes = tempRouter.prefixRoutes.get(\"OPTIONS\") ||\n        new Map();\n    optionsPrefixes.set(routeSpec.pathPrefix, optionsHandler);\n    tempRouter.prefixRoutes.set(\"OPTIONS\", optionsPrefixes);\n}\n/**\n * Creates an OPTIONS handler for the given HTTP methods.\n * @param methods Array of HTTP methods to be allowed.\n * @returns A CORS-enabled OPTIONS handler.\n */\nfunction createOptionsHandlerForMethods(methods, config) {\n    return handleCors({\n        ...config,\n        allowedMethods: methods,\n    });\n}\nexport default corsRouter;\n/**\n * handleCors() is a higher-order function that wraps a Convex HTTP action handler to add CORS support.\n * It allows for customization of allowed HTTP methods and origins for cross-origin requests.\n *\n * The function:\n * 1. Validates and normalizes the allowed HTTP methods.\n * 2. Generates appropriate CORS headers based on the provided configuration.\n * 3. Handles preflight OPTIONS requests automatically.\n * 4. Wraps the original handler to add CORS headers to its response.\n *\n * This helper simplifies the process of making Convex HTTP actions accessible\n * to web applications hosted on different domains.\n */\nconst SECONDS_IN_A_DAY = 60 * 60 * 24;\n/**\n * Example CORS origins:\n * - \"*\" (allow all origins)\n * - \"https://example.com\" (allow a specific domain)\n * - \"https://*.example.com\" (allow all subdomains of example.com)\n * - \"https://example1.com, https://example2.com\" (allow multiple specific domains)\n * - \"null\" (allow requests from data URLs or local files)\n */\nconst handleCors = ({ originalHandler, allowedMethods = [\"OPTIONS\"], allowedOrigins = [\"*\"], allowedHeaders = [\"Content-Type\"], exposedHeaders = DEFAULT_EXPOSED_HEADERS, allowCredentials = false, browserCacheMaxAge = SECONDS_IN_A_DAY, enforceAllowOrigins = false, debug = false, }) => {\n    const uniqueMethods = Array.from(new Set(allowedMethods.map((method) => method.toUpperCase())));\n    const filteredMethods = uniqueMethods.filter((method) => ROUTABLE_HTTP_METHODS.includes(method));\n    if (filteredMethods.length === 0) {\n        throw new Error(\"No valid HTTP methods provided\");\n    }\n    /**\n     * Ensure OPTIONS is not duplicated if it was passed in\n     * E.g. if allowedMethods = [\"GET\", \"OPTIONS\"]\n     */\n    const allowMethods = filteredMethods.includes(\"OPTIONS\")\n        ? filteredMethods.join(\", \")\n        : [...filteredMethods].join(\", \");\n    /**\n     * Build up the set of CORS headers\n     */\n    const commonHeaders = {\n        Vary: \"Origin\",\n    };\n    if (allowCredentials) {\n        commonHeaders[\"Access-Control-Allow-Credentials\"] = \"true\";\n    }\n    if (exposedHeaders.length > 0) {\n        commonHeaders[\"Access-Control-Expose-Headers\"] = exposedHeaders.join(\", \");\n    }\n    async function parseAllowedOrigins(request) {\n        return Array.isArray(allowedOrigins)\n            ? allowedOrigins\n            : await allowedOrigins(request);\n    }\n    // Helper function to check if origin is allowed (including wildcard subdomain matching)\n    async function isAllowedOrigin(request) {\n        const requestOrigin = request.headers.get(\"origin\");\n        if (!requestOrigin)\n            return false;\n        return (await parseAllowedOrigins(request)).some((allowed) => {\n            if (allowed === \"*\")\n                return true;\n            if (allowed === requestOrigin)\n                return true;\n            if (allowed.startsWith(\"*.\")) {\n                const wildcardDomain = allowed.slice(1); // \".bar.com\"\n                const rootDomain = allowed.slice(2); // \"bar.com\"\n                try {\n                    const url = new URL(requestOrigin);\n                    return (url.protocol === \"https:\" &&\n                        (url.hostname.endsWith(wildcardDomain) ||\n                            url.hostname === rootDomain));\n                }\n                catch {\n                    return false; // Invalid URL format\n                }\n            }\n            return false;\n        });\n    }\n    /**\n     * Return our modified HTTP action\n     */\n    return httpActionGeneric(async (ctx, request) => {\n        if (debug) {\n            console.log(\"CORS request\", {\n                path: request.url,\n                origin: request.headers.get(\"origin\"),\n                headers: request.headers,\n                method: request.method,\n                body: request.body,\n            });\n        }\n        const requestOrigin = request.headers.get(\"origin\");\n        const parsedAllowedOrigins = await parseAllowedOrigins(request);\n        if (debug) {\n            console.log(\"allowed origins\", parsedAllowedOrigins);\n        }\n        // Handle origin matching\n        let allowOrigins = null;\n        if (parsedAllowedOrigins.includes(\"*\") &&\n            requestOrigin &&\n            !allowCredentials) {\n            allowOrigins = requestOrigin;\n        }\n        else if (requestOrigin) {\n            // Check if the request origin matches any of the allowed origins\n            // (including wildcard subdomain matching if configured)\n            if (await isAllowedOrigin(request)) {\n                allowOrigins = requestOrigin;\n            }\n        }\n        if (enforceAllowOrigins && !allowOrigins) {\n            // Origin not allowed\n            console.error(`Request from origin ${requestOrigin} blocked, missing from allowed origins: ${parsedAllowedOrigins.join()}`);\n            return new Response(null, { status: 403 });\n        }\n        /**\n         * OPTIONS has no handler and just returns headers\n         */\n        if (request.method === \"OPTIONS\") {\n            const responseHeaders = new Headers({\n                ...commonHeaders,\n                ...(allowOrigins\n                    ? { \"Access-Control-Allow-Origin\": allowOrigins }\n                    : {}),\n                \"Access-Control-Allow-Methods\": allowMethods,\n                \"Access-Control-Allow-Headers\": allowedHeaders.join(\", \"),\n                \"Access-Control-Max-Age\": browserCacheMaxAge.toString(),\n            });\n            if (debug) {\n                console.log(\"CORS OPTIONS response headers\", responseHeaders);\n            }\n            return new Response(null, {\n                status: 204,\n                headers: responseHeaders,\n            });\n        }\n        /**\n         * If the method is not OPTIONS, it must pass a handler\n         */\n        if (!originalHandler) {\n            throw new Error(\"No PublicHttpAction provider to CORS handler\");\n        }\n        /**\n         * First, execute the original handler\n         */\n        const innerHandler = (\"_handler\" in originalHandler\n            ? originalHandler[\"_handler\"]\n            : originalHandler);\n        const originalResponse = await innerHandler(ctx, request);\n        /**\n         * Second, get a copy of the original response's headers and add the\n         * allow origin header if it's allowed\n         */\n        const newHeaders = new Headers(originalResponse.headers);\n        if (allowOrigins) {\n            newHeaders.set(\"Access-Control-Allow-Origin\", allowOrigins);\n        }\n        /**\n         * Third, add or update our other CORS headers\n         */\n        Object.entries(commonHeaders).forEach(([key, value]) => {\n            newHeaders.set(key, value);\n        });\n        if (debug) {\n            console.log(\"CORS response headers\", newHeaders);\n        }\n        /**\n         * Fourth, return the modified Response.\n         * A Response object is immutable, so we create a new one to return here.\n         */\n        return new Response(originalResponse.body, {\n            status: originalResponse.status,\n            statusText: originalResponse.statusText,\n            headers: newHeaders,\n        });\n    });\n};\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC;;;;;;;;AACD;AAAA;AAAA;;AACO,MAAM,0BAA0B;IACnC,qBAAqB;IACrB;IACA;CACH;AAMM,MAAM,aAAa,CAAC,MAAM;IAC7B,MAAM,4BAA4B,IAAI;IACtC,MAAM,6BAA6B,IAAI;IACvC,OAAO;QACH;QACA,OAAO,CAAC;YACJ,MAAM,aAAa,IAAA,0KAAU;YAC7B,WAAW,WAAW,GAAG,KAAK,WAAW;YACzC,WAAW,YAAY,GAAG,KAAK,YAAY;YAC3C,MAAM,SAAS;gBACX,GAAG,UAAU;gBACb,GAAG,SAAS;YAChB;YACA,MAAM,kBAAkB,WAAW;gBAC/B,iBAAiB,UAAU,OAAO;gBAClC,gBAAgB;oBAAC,UAAU,MAAM;iBAAC;gBAClC,GAAG,MAAM;YACb;YACA;;;aAGC,GACD,IAAI,UAAU,WAAW;gBACrB,IAAI,UAAU,0BAA0B,GAAG,CAAC,UAAU,IAAI;gBAC1D,IAAI,CAAC,SAAS;oBACV,UAAU,IAAI;oBACd,0BAA0B,GAAG,CAAC,UAAU,IAAI,EAAE;gBAClD;gBACA,QAAQ,GAAG,CAAC,UAAU,MAAM;gBAC5B,WAAW,KAAK,CAAC;oBACb,MAAM,UAAU,IAAI;oBACpB,QAAQ,UAAU,MAAM;oBACxB,SAAS;gBACb;gBACA,iBAAiB,YAAY,WAAW,QAAQ,MAAM,IAAI,CAAC;YAC/D,OACK;gBACD,IAAI,UAAU,2BAA2B,GAAG,CAAC,UAAU,UAAU;gBACjE,IAAI,CAAC,SAAS;oBACV,UAAU,IAAI;oBACd,2BAA2B,GAAG,CAAC,UAAU,UAAU,EAAE;gBACzD;gBACA,QAAQ,GAAG,CAAC,UAAU,MAAM;gBAC5B,WAAW,KAAK,CAAC;oBACb,YAAY,UAAU,UAAU;oBAChC,QAAQ,UAAU,MAAM;oBACxB,SAAS;gBACb;gBACA,kBAAkB,YAAY,WAAW,QAAQ,MAAM,IAAI,CAAC;YAChE;YACA;;aAEC,GACD,KAAK,WAAW,GAAG,IAAI,IAAI,WAAW,WAAW;YACjD,KAAK,YAAY,GAAG,IAAI,IAAI,WAAW,YAAY;QACvD;IACJ;AACJ;AACA;;;;CAIC,GACD,SAAS,iBAAiB,UAAU,EAAE,SAAS,EAAE,MAAM,EAAE,cAAc;IACnE,MAAM,wBAAwB,WAAW,WAAW,CAAC,GAAG,CAAC,UAAU,IAAI;IACvE;;KAEC,GACD,MAAM,iBAAiB,+BAA+B,gBAAgB;IACtE,kCAAA,4CAAA,sBAAuB,GAAG,CAAC,WAAW;IACtC,WAAW,WAAW,CAAC,GAAG,CAAC,UAAU,IAAI,EAAE,IAAI,IAAI;AACvD;AACA;;;;CAIC,GACD,SAAS,kBAAkB,UAAU,EAAE,SAAS,EAAE,MAAM,EAAE,cAAc;IACpE;;;;KAIC,GACD,MAAM,iBAAiB,+BAA+B,gBAAgB;IACtE,MAAM,kBAAkB,WAAW,YAAY,CAAC,GAAG,CAAC,cAChD,IAAI;IACR,gBAAgB,GAAG,CAAC,UAAU,UAAU,EAAE;IAC1C,WAAW,YAAY,CAAC,GAAG,CAAC,WAAW;AAC3C;AACA;;;;CAIC,GACD,SAAS,+BAA+B,OAAO,EAAE,MAAM;IACnD,OAAO,WAAW;QACd,GAAG,MAAM;QACT,gBAAgB;IACpB;AACJ;uCACe;AACf;;;;;;;;;;;;CAYC,GACD,MAAM,mBAAmB,KAAK,KAAK;AACnC;;;;;;;CAOC,GACD,MAAM,aAAa;QAAC,EAAE,eAAe,EAAE,iBAAiB;QAAC;KAAU,EAAE,iBAAiB;QAAC;KAAI,EAAE,iBAAiB;QAAC;KAAe,EAAE,iBAAiB,uBAAuB,EAAE,mBAAmB,KAAK,EAAE,qBAAqB,gBAAgB,EAAE,sBAAsB,KAAK,EAAE,QAAQ,KAAK,EAAG;IACpR,MAAM,gBAAgB,MAAM,IAAI,CAAC,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC,SAAW,OAAO,WAAW;IAC1F,MAAM,kBAAkB,cAAc,MAAM,CAAC,CAAC,SAAW,qLAAqB,CAAC,QAAQ,CAAC;IACxF,IAAI,gBAAgB,MAAM,KAAK,GAAG;QAC9B,MAAM,IAAI,MAAM;IACpB;IACA;;;KAGC,GACD,MAAM,eAAe,gBAAgB,QAAQ,CAAC,aACxC,gBAAgB,IAAI,CAAC,QACrB;WAAI;KAAgB,CAAC,IAAI,CAAC;IAChC;;KAEC,GACD,MAAM,gBAAgB;QAClB,MAAM;IACV;IACA,IAAI,kBAAkB;QAClB,aAAa,CAAC,mCAAmC,GAAG;IACxD;IACA,IAAI,eAAe,MAAM,GAAG,GAAG;QAC3B,aAAa,CAAC,gCAAgC,GAAG,eAAe,IAAI,CAAC;IACzE;IACA,eAAe,oBAAoB,OAAO;QACtC,OAAO,MAAM,OAAO,CAAC,kBACf,iBACA,MAAM,eAAe;IAC/B;IACA,wFAAwF;IACxF,eAAe,gBAAgB,OAAO;QAClC,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC;QAC1C,IAAI,CAAC,eACD,OAAO;QACX,OAAO,CAAC,MAAM,oBAAoB,QAAQ,EAAE,IAAI,CAAC,CAAC;YAC9C,IAAI,YAAY,KACZ,OAAO;YACX,IAAI,YAAY,eACZ,OAAO;YACX,IAAI,QAAQ,UAAU,CAAC,OAAO;gBAC1B,MAAM,iBAAiB,QAAQ,KAAK,CAAC,IAAI,aAAa;gBACtD,MAAM,aAAa,QAAQ,KAAK,CAAC,IAAI,YAAY;gBACjD,IAAI;oBACA,MAAM,MAAM,IAAI,IAAI;oBACpB,OAAQ,IAAI,QAAQ,KAAK,YACrB,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,mBACnB,IAAI,QAAQ,KAAK,UAAU;gBACvC,EACA,UAAM;oBACF,OAAO,OAAO,qBAAqB;gBACvC;YACJ;YACA,OAAO;QACX;IACJ;IACA;;KAEC,GACD,OAAO,IAAA,oMAAiB,EAAC,OAAO,KAAK;QACjC,IAAI,OAAO;YACP,QAAQ,GAAG,CAAC,gBAAgB;gBACxB,MAAM,QAAQ,GAAG;gBACjB,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC;gBAC5B,SAAS,QAAQ,OAAO;gBACxB,QAAQ,QAAQ,MAAM;gBACtB,MAAM,QAAQ,IAAI;YACtB;QACJ;QACA,MAAM,gBAAgB,QAAQ,OAAO,CAAC,GAAG,CAAC;QAC1C,MAAM,uBAAuB,MAAM,oBAAoB;QACvD,IAAI,OAAO;YACP,QAAQ,GAAG,CAAC,mBAAmB;QACnC;QACA,yBAAyB;QACzB,IAAI,eAAe;QACnB,IAAI,qBAAqB,QAAQ,CAAC,QAC9B,iBACA,CAAC,kBAAkB;YACnB,eAAe;QACnB,OACK,IAAI,eAAe;YACpB,iEAAiE;YACjE,wDAAwD;YACxD,IAAI,MAAM,gBAAgB,UAAU;gBAChC,eAAe;YACnB;QACJ;QACA,IAAI,uBAAuB,CAAC,cAAc;YACtC,qBAAqB;YACrB,QAAQ,KAAK,CAAC,AAAC,uBAA8E,OAAxD,eAAc,4CAAsE,OAA5B,qBAAqB,IAAI;YACtH,OAAO,IAAI,SAAS,MAAM;gBAAE,QAAQ;YAAI;QAC5C;QACA;;SAEC,GACD,IAAI,QAAQ,MAAM,KAAK,WAAW;YAC9B,MAAM,kBAAkB,IAAI,QAAQ;gBAChC,GAAG,aAAa;gBAChB,GAAI,eACE;oBAAE,+BAA+B;gBAAa,IAC9C,CAAC,CAAC;gBACR,gCAAgC;gBAChC,gCAAgC,eAAe,IAAI,CAAC;gBACpD,0BAA0B,mBAAmB,QAAQ;YACzD;YACA,IAAI,OAAO;gBACP,QAAQ,GAAG,CAAC,iCAAiC;YACjD;YACA,OAAO,IAAI,SAAS,MAAM;gBACtB,QAAQ;gBACR,SAAS;YACb;QACJ;QACA;;SAEC,GACD,IAAI,CAAC,iBAAiB;YAClB,MAAM,IAAI,MAAM;QACpB;QACA;;SAEC,GACD,MAAM,eAAgB,cAAc,kBAC9B,eAAe,CAAC,WAAW,GAC3B;QACN,MAAM,mBAAmB,MAAM,aAAa,KAAK;QACjD;;;SAGC,GACD,MAAM,aAAa,IAAI,QAAQ,iBAAiB,OAAO;QACvD,IAAI,cAAc;YACd,WAAW,GAAG,CAAC,+BAA+B;QAClD;QACA;;SAEC,GACD,OAAO,OAAO,CAAC,eAAe,OAAO,CAAC;gBAAC,CAAC,KAAK,MAAM;YAC/C,WAAW,GAAG,CAAC,KAAK;QACxB;QACA,IAAI,OAAO;YACP,QAAQ,GAAG,CAAC,yBAAyB;QACzC;QACA;;;SAGC,GACD,OAAO,IAAI,SAAS,iBAAiB,IAAI,EAAE;YACvC,QAAQ,iBAAiB,MAAM;YAC/B,YAAY,iBAAiB,UAAU;YACvC,SAAS;QACb;IACJ;AACJ","ignoreList":[0],"debugId":null}}]
}